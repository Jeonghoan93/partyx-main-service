"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToMongoOperators = void 0;
const get_typed_value_1 = require("./get-typed-value");
const operatorsBlackList = ['$where'];
function convertToMongoOperators(key, value, { dateFields, objectIdFields } = {}) {
    const join = value === '' ? key : key.concat('=', value);
    const parts = join.match(/^(!?[^><!=:]+)(?:=?([><]=?|!?=|:.+=)(.+))?$/);
    const fieldQueryCriteria = {};
    let parseDate = false;
    let parseObjectId = false;
    let op;
    if (!parts) {
        return null;
    }
    key = parts[1];
    op = parts[2];
    if (Array.isArray(dateFields) && dateFields.indexOf(key) > -1) {
        parseDate = true;
    }
    if (Array.isArray(objectIdFields) && objectIdFields.indexOf(key) > -1) {
        parseObjectId = true;
    }
    if (!op) {
        if (key[0] !== '!') {
            value = { $exists: true };
        }
        else {
            key = key.substr(1);
            value = { $exists: false };
        }
    }
    else if (op === '=' && parts[3] === '!') {
        value = { $exists: false };
    }
    else if (op === '=' || op === '!=') {
        if (op === '=' && parts[3][0] === '!') {
            op = '!=';
        }
        const array = (0, get_typed_value_1.getTypedValues)(parts[3], { parseDate, parseObjectId });
        if (array.length > 1) {
            value = {};
            op = op === '=' ? '$in' : '$nin';
            value[op] = array;
        }
        else if (op === '!=') {
            value = array[0] instanceof RegExp ? { $not: array[0] } : { $ne: array[0] };
        }
        else {
            value = array[0];
        }
    }
    else if (op[0] === ':' && op[op.length - 1] === '=') {
        op = '$' + op.substr(1, op.length - 2);
        if (operatorsBlackList.indexOf(op) > -1) {
            throw new Error(`Use of the operator ${op} is forbidden to prevent NoSQL injections.`);
        }
        const array = parts[3].split(',').map(val => (0, get_typed_value_1.getTypedValue)(val, { parseDate, parseObjectId }));
        if (op === '$or') {
            value = array.length === 1 ? { [key]: array[0] } : array.map(val => ({ [key]: val }));
            key = op;
        }
        else {
            value = {};
            value[op] = array.length === 1 ? array[0] : array;
        }
    }
    else {
        value = (0, get_typed_value_1.getTypedValue)(parts[3], { parseDate, parseObjectId });
        if (op === '>') {
            value = { $gt: value };
        }
        else if (op === '>=') {
            value = { $gte: value };
        }
        else if (op === '<') {
            value = { $lt: value };
        }
        else if (op === '<=') {
            value = { $lte: value };
        }
    }
    fieldQueryCriteria.key = key;
    fieldQueryCriteria.value = value;
    return fieldQueryCriteria;
}
exports.convertToMongoOperators = convertToMongoOperators;
//# sourceMappingURL=mongo-operators.js.map