"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryCriteriaToMongo = void 0;
const mongo_operators_1 = require("../convert/mongo-operators");
const get_typed_value_1 = require("../convert/get-typed-value");
const hasOrdinalKeys = (obj) => {
    let c = 0;
    for (const key in obj) {
        if (Number(key) !== c++) {
            return false;
        }
    }
    return true;
};
function queryCriteriaToMongo(query, { dateFields, ignore, objectIdFields, fullTextFields, qParameter } = {}) {
    const criteria = {};
    for (const key of Object.keys(query)) {
        if (!ignore || ignore.indexOf(key) === -1 || key === qParameter) {
            if (key === qParameter) {
                if (!Array.isArray(fullTextFields) || fullTextFields.length === 0) {
                    throw new Error(`Fulltext search is not enabled for this resource.`);
                }
                criteria.$or = fullTextFields
                    .map(function (field) {
                    const regexp = (0, get_typed_value_1.regexpTest)(query[key]);
                    let p;
                    if (regexp && regexp[1].length) {
                        const words = regexp[1].split(' ').filter(Boolean);
                        if (words.length > 1) {
                            const andArray = words.reduce((and, word) => {
                                const regexpedWord = `/${word}/${regexp[2]}`;
                                const wordP = (0, mongo_operators_1.convertToMongoOperators)(field, regexpedWord, {
                                    dateFields,
                                    objectIdFields,
                                });
                                if (wordP) {
                                    return and.concat([{ [field]: wordP.value }]);
                                }
                            }, []);
                            return { $and: andArray };
                        }
                    }
                    p = (0, mongo_operators_1.convertToMongoOperators)(field, query[key], { dateFields, objectIdFields });
                    if (p) {
                        return { [field]: p.value };
                    }
                })
                    .filter(Boolean);
            }
            else {
                const deep = typeof query[key] === 'object' && !hasOrdinalKeys(query[key]);
                const p = deep
                    ? {
                        key: key,
                        value: queryCriteriaToMongo(query[key], { dateFields, objectIdFields }),
                    }
                    : (0, mongo_operators_1.convertToMongoOperators)(key, query[key], { dateFields, objectIdFields });
                if (p) {
                    if (!criteria[p.key]) {
                        criteria[p.key] = p.value;
                    }
                    else {
                        criteria[p.key] = Object.assign(criteria[p.key], p.value);
                    }
                }
            }
        }
    }
    return criteria;
}
exports.queryCriteriaToMongo = queryCriteriaToMongo;
//# sourceMappingURL=criteria-to-mongo.js.map