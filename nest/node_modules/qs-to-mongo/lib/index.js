"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const qs_1 = __importDefault(require("qs"));
const criteria_to_mongo_1 = require("./query/criteria-to-mongo");
const options_to_mongo_1 = require("./query/options-to-mongo");
const defaultParameters = {
    fields: 'fields',
    omit: 'omit',
    sort: 'sort',
    offset: 'offset',
    limit: 'limit',
    q: 'q',
};
function qsToMongo(query, options = {}) {
    const { parser = qs_1.default, parserOptions, ignoredFields = [], maxLimit } = options;
    let { dateFields, objectIdFields, fullTextFields } = options;
    const parameters = Object.assign(Object.assign({}, defaultParameters), options.parameters);
    const queryString = typeof query === 'string' ? parser.parse(query, parserOptions) : query;
    const ignore = []
        .concat(typeof ignoredFields === 'string' ? [ignoredFields] : ignoredFields)
        .concat(Object.values(parameters));
    dateFields = typeof dateFields === 'string' ? [dateFields] : dateFields;
    objectIdFields = typeof objectIdFields === 'string' ? [objectIdFields] : objectIdFields;
    fullTextFields = typeof fullTextFields === 'string' ? [fullTextFields] : fullTextFields;
    const parsedOptions = (0, options_to_mongo_1.parseQueryOptions)(queryString, { maxLimit, parameters });
    return {
        criteria: (0, criteria_to_mongo_1.queryCriteriaToMongo)(queryString, {
            dateFields,
            ignore,
            objectIdFields,
            fullTextFields,
            qParameter: parameters.q,
        }),
        options: parsedOptions,
        links: function (url, totalCount) {
            const offset = parsedOptions.skip || 0;
            const limit = Math.min(parsedOptions.limit || 0, totalCount);
            const links = {};
            const last = {};
            if (!limit) {
                return null;
            }
            if (offset > 0) {
                queryString[parameters.offset] = Math.max(offset - limit, 0);
                links.prev = url + '?' + parser.stringify(queryString);
                queryString[parameters.offset] = 0;
                links.first = url + '?' + parser.stringify(queryString);
            }
            if (offset + limit < totalCount) {
                last.pages = Math.ceil(totalCount / limit);
                last.offset = (last.pages - 1) * limit;
                queryString[parameters.offset] = Math.min(offset + limit, last.offset);
                links.next = url + '?' + parser.stringify(queryString);
                queryString[parameters.offset] = last.offset;
                links.last = url + '?' + parser.stringify(queryString);
            }
            return links;
        },
    };
}
module.exports = qsToMongo;
//# sourceMappingURL=index.js.map